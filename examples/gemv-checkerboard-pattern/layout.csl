// Copyright 2022 Cerebras Systems.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This does y = Ax + b (A is 32x16) on a 4x4 rectangle of PEs.

param x_in : color;     // color for input X from NORTH to kernel
param sentinel : color; // sentinel color for X

// These colors are involved in the checkerboard pattern
param b_in : color;     // color for input B from WEST to kernel
param ax_out : color;   // alternate color for passing result towards EAST
param y_out : color;    // color for output Y from kernel to EAST

// Program uses 4x4 rectangle of PEs
const kernel_rows : i16 = 4; // Height of kernel
const kernel_cols : i16 = 4; // Width of kernel

// Global A, B, X dims
const matrix_rows : i16 = 32; // Height of matrix
const matrix_cols : i16 = 16; // Width of matrix

const A_rows : i16 = matrix_rows;
const A_cols : i16 = matrix_cols;

const X_rows : i16 = matrix_cols;
const X_cols : i16 = 1;

const B_rows : i16 = matrix_rows;
const B_cols : i16 = 1;

// A, B, X dims per PE
const A_local_dim_x : i16 = A_rows / kernel_rows;
const A_local_dim_y : i16 = A_cols / kernel_cols;

const X_local_dim_x : i16 = X_rows / kernel_rows;
const X_local_dim_y : i16 = X_cols;

const B_local_dim_x : i16 = B_rows / kernel_rows;
const B_local_dim_y : i16 = B_cols;

layout {
  // @set_rectangle takes width and height arguments in order.
  @set_rectangle(kernel_cols, kernel_rows);

  const same_colors    = .{.x_in=x_in, .recv = b_in,   .send = ax_out, .sentinel=sentinel};
  const swapped_colors = .{.x_in=x_in, .recv = ax_out, .send = b_in,   .sentinel=sentinel};
  const send_right     = .{.x_in=x_in, .recv = ax_out, .send = y_out,  .sentinel=sentinel};

  const dimensions = .{ .A_local_dim_x = A_local_dim_x,
                        .A_local_dim_y = A_local_dim_y,
                        .X_local_dim_x = X_local_dim_x,
                        .X_local_dim_y = X_local_dim_y,
                        .B_local_dim_x = B_local_dim_x,
                        .B_local_dim_y = B_local_dim_y };

  for (@range(i16, kernel_cols - 1)) |i| {
    for (@range(i16, kernel_rows)) |j| {
      if (i % 2 == 1) {
        @set_tile_code(i, j, "pe.csl", @concat_structs(dimensions, swapped_colors));
      } else {
        @set_tile_code(i, j, "pe.csl", @concat_structs(dimensions, same_colors));
      }
    }
  }

  // Configure the last column of PEs
  for (@range(i16, kernel_rows)) |i| {
    @set_tile_code(kernel_cols - 1, i, "pe.csl", @concat_structs(dimensions, send_right));
  }

  // Create route values
  const RX_N_TX_RS = .{.rx=.{NORTH}, .tx=.{RAMP, SOUTH}};
  const RX_N_TX_R = .{.rx=.{NORTH}, .tx=.{RAMP}};
  const RX_W_TX_R = .{.rx=.{WEST}, .tx=.{RAMP}};
  const RX_R_TX_E = .{.rx=.{RAMP}, .tx=.{EAST}};

  for (@range(i16, kernel_cols)) |i| {
    for (@range(i16, kernel_rows)) |j| {
      // On even columns, b_in is "recv" color, receiving values
      // from west and transmitted down ramp for computation.
      // On odd columns, b_in is "send" color, receiving values
      // up ramp and sending to east.
      // On last column, however, b_in is not used.
      // On leftmost (0th) column, b_in receives B from the host.
      if (i % 2 == 0) {
        @set_color_config(i, j, b_in, .{.routes = RX_W_TX_R });
      } else if (i == 1) {
        @set_color_config(i, j, b_in, .{.routes = RX_R_TX_E });
      }

      // On even columns, ax_out is "send" color, receiving values
      // up ramp and sending to east.
      // On odd columns, ax_out is "recv" color, receiving values
      // from west and transmitting down ramp for computation.
      if (i % 2 == 0) {
        @set_color_config(i, j, ax_out, .{.routes = RX_R_TX_E });
      } else {
        @set_color_config(i, j, ax_out, .{.routes = RX_W_TX_R });
      }

      // On last column, y_out is "send" color, sending final Y
      // values to east where they are streamed off fabric.
      if (i == kernel_cols - 1) {
        @set_color_config(i, j, y_out, .{.routes = RX_R_TX_E });
      }

      // All rows transmit X values down ramp for computation.
      // All rows except last row must also propagate X values south.
      // The last row will not propagate X values.
      if (j == kernel_rows - 1) {
        @set_color_config(i, j, x_in, .{.routes = RX_N_TX_R});
      } else {
        @set_color_config(i, j, x_in, .{.routes = RX_N_TX_RS});
      }
    }
  }
}
