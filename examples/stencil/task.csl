// Eight colors, two in each cardinal direction, to communicated between PEs
param colorTxToWest: color;
param colorRxFromEast: color;

param colorTxToEast: color;
param colorRxFromWest: color;

param colorTxToNorth: color;
param colorRxFromSouth: color;

param colorTxToSouth: color;
param colorRxFromNorth: color;

param colorExch: color;
param colorCompute: color;

param colorTxWestComplete: color;
param colorTxEastComplete: color;
param colorTxNorthComplete: color;
param colorTxSouthComplete: color;

param colorRxWestComplete: color;
param colorRxEastComplete: color;
param colorRxNorthComplete: color;
param colorRxSouthComplete: color;

param timeSteps: i16;
param ghostCells: i16;

// Local (i.e. per-PE) data size
param dataWidth: i16;
param dataHeight: i16;
param dataDepth: i16;

param hPeCount: i16;
param vPeCount: i16;

param isOnEastBoundary: bool;
param isOnWestBoundary: bool;
param isOnNorthBoundary: bool;
param isOnSouthBoundary: bool;

param tallyParams: comptime_struct;

const tally = @import_module("<kernels/tally/pe>",
  @concat_structs(tallyParams, .{
    .output_queues=[2]u16{4, 5}, // we use 0-3 below
  }));

// Is this the only PE in the entire rectangle?
const isLonePe = isOnEastBoundary and isOnWestBoundary and
    isOnNorthBoundary and isOnSouthBoundary;

var iterationCount:i16 = 1;

const init = @import_module("init.csl", .{
  .dataDepth = dataDepth,
  .dataHeight = dataHeight,
  .dataWidth = dataWidth,
  .ghostCells = ghostCells,
});

var data = init.initializeData();

const dsd0Data = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, dataWidth} ->
    data[0, ghostCells + i, ghostCells + j, ghostCells + k]
  }
);

const dsd1Data = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, dataWidth} ->
    data[1, ghostCells + i, ghostCells + j, ghostCells + k]
  }
);

const dsdData = [2]mem4d_dsd { dsd0Data, dsd1Data };

// fabric dsd to receive wavelets from west neighbor
const dsdWestRx = @get_dsd(fabin_dsd, .{
  .fabric_color = colorRxFromWest,
  .extent = dataDepth * dataHeight * ghostCells,
  .input_queue = 4,
});

// fabric dsd to send wavelets to west neighbor
const dsdWestTx = @get_dsd(fabout_dsd, .{
  .fabric_color = colorTxToWest,
  .extent = dataDepth * dataHeight * ghostCells,
  .output_queue = 0,
});

// fabric dsd to receive wavelets from east neighbor
const dsdEastRx = @get_dsd(fabin_dsd, .{
  .fabric_color = colorRxFromEast,
  .extent = dataDepth * dataHeight * ghostCells,
  .input_queue = 5,
});

// fabric dsd to send wavelets to east neighbor
const dsdEastTx = @get_dsd(fabout_dsd, .{
  .fabric_color = colorTxToEast,
  .extent = dataDepth * dataHeight * ghostCells,
  .output_queue = 1,
});

// fabric dsd to receive wavelets from north neighbor
const dsdNorthRx = @get_dsd(fabin_dsd, .{
  .fabric_color = colorRxFromNorth,
  .extent = ghostCells * dataDepth * dataWidth,
  .input_queue = 6,
});

// fabric dsd to send wavelets to north neighbor
const dsdNorthTx = @get_dsd(fabout_dsd, .{
  .fabric_color = colorTxToNorth,
  .extent = ghostCells * dataDepth * dataWidth,
  .output_queue = 2,
});

// fabric dsd to receive wavelets from south neighbor
const dsdSouthRx = @get_dsd(fabin_dsd, .{
  .fabric_color = colorRxFromSouth,
  .extent = ghostCells * dataDepth * dataWidth,
  .input_queue = 7,
});

// fabric dsd to send wavelets to south neighbor
const dsdSouthTx = @get_dsd(fabout_dsd, .{
  .fabric_color = colorTxToSouth,
  .extent = ghostCells * dataDepth * dataWidth,
  .output_queue = 3,
});

// mem4d vector to send a portion of the data to the west neighbor
const dsd0WestData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[0, ghostCells + i, ghostCells + j, ghostCells + k]
  }
);

const dsd1WestData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[1, ghostCells + i, ghostCells + j, ghostCells + k]
  }
);

const dsdWestData = [2]mem4d_dsd { dsd0WestData, dsd1WestData };

// mem4d vector to send a portion of the data to the east neighbor
const dsd0EastData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[0, ghostCells + i, ghostCells + j, dataWidth + k]
  }
);

const dsd1EastData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[1, ghostCells + i, ghostCells + j, dataWidth + k]
  }
);

const dsdEastData = [2]mem4d_dsd { dsd0EastData, dsd1EastData };

// mem4d vector to send a portion of the data to the north neighbor
const dsd0NorthData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[0, ghostCells + i, ghostCells + j, ghostCells + k]
  }
);

const dsd1NorthData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[1, ghostCells + i, ghostCells + j, ghostCells + k]
  }
);

const dsdNorthData = [2]mem4d_dsd { dsd0NorthData, dsd1NorthData };

// mem4d vector to send a portion of the data to the south neighbor
const dsd0SouthData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[0, ghostCells + i, dataHeight + j, ghostCells + k]
  }
);

const dsd1SouthData = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[1, ghostCells + i, dataHeight + j, ghostCells + k]
  }
);

const dsdSouthData = [2]mem4d_dsd { dsd0SouthData, dsd1SouthData };

fn sendToNeighbors(toggle: i16) void {
  if (!isOnWestBoundary) {
    @fmovh(dsdWestTx, dsdWestData[toggle], .{
      .async = true, .activate = txWestCompleteTask
    });
  }

  if (!isOnEastBoundary) {
    @fmovh(dsdEastTx, dsdEastData[toggle], .{
      .async = true, .activate = txEastCompleteTask
    });
  }

  if (!isOnNorthBoundary) {
    @fmovh(dsdNorthTx, dsdNorthData[toggle], .{
      .async = true, .activate = txNorthCompleteTask
    });
  }

  if (!isOnSouthBoundary) {
    @fmovh(dsdSouthTx, dsdSouthData[toggle], .{
      .async = true, .activate = txSouthCompleteTask
    });
  }
}

// compute the number of directions that a PE will send to and receive from
// for instance PEs on the corner of the rectangle will send/recv from 2 PEs
// PEs on the top edge of the rectangle will send/recv from 3 PEs, etc.
fn computeMaxExchCount() i16 {
  const west = @as(i16, isOnWestBoundary);
  const east = @as(i16, isOnEastBoundary);
  const north = @as(i16, isOnNorthBoundary);
  const south = @as(i16, isOnSouthBoundary);

  return 2 * (4 - west - east - north - south);
}

var exchCount:i16 = 0;

fn exchCompleteFn() void {
  exchCount += 1;

  // If we've exchanged data with all neighbors, then trigger the computation
  if (exchCount == comptime computeMaxExchCount()) {
    @activate(colorCompute);
  }
}

task rxWestCompleteTask() void {
  exchCompleteFn();
}

task rxEastCompleteTask() void {
  exchCompleteFn();
}

task rxNorthCompleteTask() void {
  exchCompleteFn();
}

task rxSouthCompleteTask() void {
  exchCompleteFn();
}

task txWestCompleteTask() void {
  exchCompleteFn();
}

task txEastCompleteTask() void {
  exchCompleteFn();
}

task txNorthCompleteTask() void {
  exchCompleteFn();
}

task txSouthCompleteTask() void {
  exchCompleteFn();
}

// fabric dsd to receive into ghost cells from the west neighbor
const dsd0WestGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[0, ghostCells + i, ghostCells + j, k]
  }
);

const dsd1WestGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[1, ghostCells + i, ghostCells + j, k]
  }
);

const dsdWestGhost = [2]mem4d_dsd { dsd0WestGhost, dsd1WestGhost };

// fabric dsd to receive into ghost cells from the east neighbor
const dsd0EastGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[0, ghostCells + i, ghostCells + j, ghostCells + dataWidth + k]
  }
);

const dsd1EastGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, dataHeight, ghostCells} ->
    data[1, ghostCells + i, ghostCells + j, ghostCells + dataWidth + k]
  }
);

const dsdEastGhost = [2]mem4d_dsd { dsd0EastGhost, dsd1EastGhost };

// fabric dsd to receive into ghost cells from the north neighbor
const dsd0NorthGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[0, ghostCells + i, j, ghostCells + k]
  }
);

const dsd1NorthGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[1, ghostCells + i, j, ghostCells + k]
  }
);

const dsdNorthGhost = [2]mem4d_dsd { dsd0NorthGhost, dsd1NorthGhost };

// fabric dsd to receive into ghost cells from the south neighbor
const dsd0SouthGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[0, ghostCells + i, ghostCells + dataHeight + j, ghostCells + k]
  }
);

const dsd1SouthGhost = @get_dsd(mem4d_dsd, .{
  .tensor_access = |i, j, k|{dataDepth, ghostCells, dataWidth} ->
    data[1, ghostCells + i, ghostCells + dataHeight + j, ghostCells + k]
  }
);

const dsdSouthGhost = [2]mem4d_dsd { dsd0SouthGhost, dsd1SouthGhost };

fn recvFromNeighbors(toggle: i16) void {
  if (!isOnWestBoundary) {
    @fmovh(dsdWestGhost[toggle], dsdWestRx, .{
      .async = true, .activate = rxWestCompleteTask
    });
  }

  if (!isOnEastBoundary) {
    @fmovh(dsdEastGhost[toggle], dsdEastRx, .{
      .async = true, .activate = rxEastCompleteTask
    });
  }

  if (!isOnNorthBoundary) {
    @fmovh(dsdNorthGhost[toggle], dsdNorthRx, .{
      .async = true, .activate = rxNorthCompleteTask
    });
  }

  if (!isOnSouthBoundary) {
    @fmovh(dsdSouthGhost[toggle], dsdSouthRx, .{
      .async = true, .activate = rxSouthCompleteTask
    });
  }
}

fn compute(toggle: i16) void {
  var i:i16 = 0;

  while (i < dataDepth) : (i += 1) {
    var j:i16 = 0;
    const baseI = ghostCells + i;

    while (j < dataHeight) : (j += 1) {
      var k:i16 = 0;
      const baseJ = ghostCells + j;

      while (k < dataWidth) : (k += 1) {
        var l:i16 = 1;
        var sum : f16 = 0.0;
        const baseK = ghostCells + k;

        while (l <= ghostCells) : (l += 1) {
          sum += data[toggle, baseI, baseJ - l, baseK] +
              data[toggle, baseI, baseJ + l, baseK] +
              data[toggle, baseI, baseJ, baseK - l] +
              data[toggle, baseI, baseJ, baseK + l] +
              data[toggle, baseI - l, baseJ, baseK] +
              data[toggle, baseI + l, baseJ, baseK];
        }

        const denominator = 6.0 * @as(f16, ghostCells);
        data[1 - toggle, baseI, baseJ, baseK] = sum / denominator;
      }
    }
  }
}

var bufferToggle:i16 = 0;

task exchangeTask() void {
  exchCount = 0;
  sendToNeighbors(bufferToggle);
  recvFromNeighbors(bufferToggle);
}

task computeTask() void {
  compute(bufferToggle);
  bufferToggle = 1 - bufferToggle;

  if (iterationCount < timeSteps) {
    iterationCount += 1;

    // If this is the only PE in the entire PE rectangle, then skip the
    // exchange step and go straight to the computation
    if (isLonePe) {
      @activate(colorCompute);
    } else {
      @activate(colorExch);
    }
  } else {
    tally.signal_completion();
  }
}

comptime {
  @bind_task(exchangeTask, colorExch);
  @bind_task(computeTask, colorCompute);

  // If this is the only PE in the entire PE rectangle, then skip the exchange
  // steps and go straight to the computation
  if (timeSteps > 0) {
    if (isLonePe) {
      @activate(colorCompute);
    } else {
      @activate(colorExch);
    }
  }

  @bind_task(rxWestCompleteTask, colorRxWestComplete);
  @bind_task(rxEastCompleteTask, colorRxEastComplete);
  @bind_task(rxNorthCompleteTask, colorRxNorthComplete);
  @bind_task(rxSouthCompleteTask, colorRxSouthComplete);

  @bind_task(txWestCompleteTask, colorTxWestComplete);
  @bind_task(txEastCompleteTask, colorTxEastComplete);
  @bind_task(txNorthCompleteTask, colorTxNorthComplete);
  @bind_task(txSouthCompleteTask, colorTxSouthComplete);

  // block colors that are used with fabric input DSDs
  @block(colorRxFromEast);
  @block(colorRxFromWest);
  @block(colorRxFromNorth);
  @block(colorRxFromSouth);

  // PEs along the west border do not have a neighbor to their west
  if (!isOnWestBoundary) {
    const inRoute = .{ .rx = .{ WEST }, .tx = .{ RAMP } };
    @set_local_color_config(colorRxFromWest, .{ .routes = inRoute });

    const outRoute = .{ .rx = .{ RAMP }, .tx = .{ WEST } };
    @set_local_color_config(colorTxToWest, .{ .routes = outRoute });
  }

  // PEs along the east border do not have a neighbor to their east
  if (!isOnEastBoundary) {
    const inRoute = .{ .rx = .{ EAST }, .tx = .{ RAMP } };
    @set_local_color_config(colorRxFromEast, .{ .routes = inRoute });

    const outRoute = .{ .rx = .{ RAMP }, .tx = .{ EAST } };
    @set_local_color_config(colorTxToEast, .{ .routes = outRoute });
  }

  // PEs along the south border do not have a neighbor to their south
  if (!isOnSouthBoundary) {
    const inRoute = .{ .rx = .{ SOUTH }, .tx = .{ RAMP } };
    @set_local_color_config(colorRxFromSouth, .{ .routes = inRoute });

    const outRoute = .{ .rx = .{ RAMP }, .tx = .{ SOUTH } };
    @set_local_color_config(colorTxToSouth, .{ .routes = outRoute });
  }

  // PEs along the north border do not have a neighbor to their north
  if (!isOnNorthBoundary) {
    const inRoute = .{ .rx = .{ NORTH }, .tx = .{ RAMP } };
    @set_local_color_config(colorRxFromNorth, .{ .routes = inRoute });

    const outRoute = .{ .rx = .{ RAMP }, .tx = .{ NORTH } };
    @set_local_color_config(colorTxToNorth, .{ .routes = outRoute });
  }
}
