// Copyright 2022 Cerebras Systems.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This does y = Ax + b (A is 32x16) on a 4x4 rectangle of PEs.

param x_in : color;     // color for input X from NORTH to kernel
param sentinel : color; // sentinel color for X

// checkerboard color for sending result to EAST
// on rightmost column of PEs, color along which y is streamed out
param send : color;

// checkerboard color for receiving result from WEST
// on leftmost column of PEs, color along with b is streamed in
param recv : color;

// dims of A, X, B chunks on PE
param A_local_dim_x : i16;
param A_local_dim_y : i16;

param X_local_dim_x : i16;
param X_local_dim_y : i16;

param B_local_dim_x : i16;
param B_local_dim_y : i16;

var A = @zeros([A_local_dim_x, A_local_dim_y]f16);
var mul_temp = @zeros([A_local_dim_x]f16);

const dsd_A = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{A_local_dim_x} -> A[i, 0], .wavelet_index_offset=true});
const dsd_mul_temp = @get_dsd(mem1d_dsd, .{ .tensor_access = |i|{A_local_dim_x} -> mul_temp[i]});

const dsd_in  = @get_dsd(fabin_dsd,  .{.fabric_color = recv, .extent = B_local_dim_x, .input_queue = @get_input_queue(@get_color_id(recv))});
const dsd_out = @get_dsd(fabout_dsd, .{ .fabric_color = send, .extent = B_local_dim_x * B_local_dim_y});

task fmac_task(wlet_data : f16, idx : u16) void {
  @fmach(dsd_mul_temp, dsd_mul_temp, dsd_A, wlet_data, .{.index = idx});
}

task sentinel_task() void {
  @faddh(dsd_out, dsd_in, dsd_mul_temp);
}

comptime {
  @bind_task(fmac_task, x_in);
  @bind_task(sentinel_task, sentinel);

  // recv is blocked to prevent (empty) task from consuming wavelets
  // before dsd_in in sentinel_task consumes them
  @block(recv);
}
