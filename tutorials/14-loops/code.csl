fn abs(input: f16) f16 {
  if (input < 0.0) {
    return -input;
  }

  return input;
}

// Computes square root of `input` using the Newton Raphson method.  Stops
// execution after running the specified iterations
fn mySqrt(input: f16, iterations: i16) f16 {
  var count: i16 = 0;
  var prev: f16 = 0.0;
  var result = input;

  // Execute iterations until we reach the terminal count
  while (count < iterations) : (count += 1) {
    // Terminate early if we've reached convergence
    if (abs(result - prev) <= 1e-6) {
      break;
    }

    prev = result;
    result = 0.5 * (result + input / result);
  }

  return result;
}

var result: f16 = 0.0;
const mainColor: color = @get_color(0);
const outputColor: color = @get_color(1);

const fabDsd = @get_dsd(fabout_dsd, .{
  .extent = 1,
  .fabric_color = outputColor,
});

task mainTask(data: f16) void {
  result = mySqrt(data, 20);
  @fmovh(fabDsd, result);
}

comptime {
  @bind_task(mainTask, mainColor);
}

layout {
  // Use a row of 10 PEs to execute this kernel
  @set_rectangle(10, 1);

  for (@range(i16, 10)) |pe_x| {
    // Each PE executes the code in the same file
    @set_tile_code(pe_x, 0, "code.csl");

    // Each PE accepts wavelets from the north and forwards them to the ramp
    const route = .{ .rx = .{ NORTH }, .tx = .{ RAMP } };
    @set_color_config(pe_x, 0, mainColor, .{ .routes = route });

    const outputRoute = .{ .rx = .{ RAMP }, .tx = .{ SOUTH } };
    @set_color_config(pe_x, 0, outputColor, .{ .routes = outputRoute });
  }
}
